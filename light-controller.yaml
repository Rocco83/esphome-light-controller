esphome:
  name: light-controller
  friendly_name: "Centralina Luci"
  # Automatically add MAC suffix to the name to avoid conflicts
  name_add_mac_suffix: true
  # Abilita gli interrupt hardware sui chip MCP all'avvio
  on_boot:
    - priority: 600 # Esegui dopo l'inizializzazione I2C
      then:
        - lambda: |-
            // --- CONFIGURAZIONE REGISTRI MCP23017 ---
            // Registri (BANK=0): GPINTENA=0x04, GPINTENB=0x05, IOCON=0x0A
  
            // Configura HUB P0 Input (0x21)
            // 0xFF = Abilita interrupt su tutti gli 8 pin della porta
            id(mcp_p0_in).write_byte(0x04, 0xFF); // GPINTENA
            id(mcp_p0_in).write_byte(0x05, 0xFF); // GPINTENB
            // 0x42 = Bit 6 (MIRROR): Unisce INTA e INTB
            //        Bit 1 (INTPOL): Active Low (Default)
            id(mcp_p0_in).write_byte(0x0A, 0x42); // IOCON
  
            // Configura HUB P1 Input (0x23)
            id(mcp_p1_in).write_byte(0x04, 0xFF); // GPINTENA
            id(mcp_p1_in).write_byte(0x05, 0xFF); // GPINTENB
            id(mcp_p1_in).write_byte(0x0A, 0x42); // IOCON
#    - priority: -100  # molto tardi: così i componenti hanno già provato a inizializzarsi
#      then:
#        - delay: 60s
#        - lambda: |-
#            bool missing = false;
#  
#            // metti qui TUTTI i tuoi MCP
#            if (id(mcp_p0_out).is_failed()) missing = true;
#            if (id(mcp_p0_in).is_failed()) missing = true;
#            if (id(mcp_p1_out).is_failed()) missing = true;
#            if (id(mcp_p1_in).is_failed()) missing = true;
#  
#            if (missing) {
#              ESP_LOGE("bootcheck", "MCP missing -> HARD reset");
#              esp_restart(); // avoid a clean shutdown
#            }


safe_mode:
  boot_is_good_after: 2min   # must be > of delay + check
  num_attempts: 10

substitutions:
  PULSE_DELAY: 500ms

esp32:
  board: esp32-poe-iso
  framework:
    type: esp-idf

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk:
    pin: GPIO17
    mode: CLK_OUT # This replaces the deprecated GPIO17_OUT
  phy_addr: 0
  power_pin:
    number: GPIO12
    ignore_strapping_warning: true

# -------------------------------------------------------------------------
# SNIPPETS INTEGRATION
# -------------------------------------------------------------------------

# Enable logging via UART
logger:
  # uncomment for i2c status etc
  #level: DEBUG
  level: INFO

# Default HA integration, OTA updater and backup http web portal
api:
  # Security note: Consider adding password: !secret device_password
  # 5m default delay. if no home assistant, then force reboot.
  # Set to 0s to disable reboot on connection loss.
  reboot_timeout: 0s

ota:
  - platform: esphome
    # Security note: Consider adding password: !secret device_password

#wifi:
#  # Read the wifi/pass from secrets.yaml and support 2 SSID
#  networks:
#  - ssid: !secret wifi_1_ssid
#    password: !secret wifi_1_password
#  - ssid: !secret wifi_2_ssid
#    password: !secret wifi_2_password

# Web server for local diagnostics
web_server:
  port: 80
  version: 3

button:
  - platform: restart
    name: "ESPHome Restart"

# -------------------------------------------------------------------------
# I2C BUS CONFIGURATION
# -------------------------------------------------------------------------
i2c:
  sda: GPIO13
  scl: GPIO16
  scan: true
  id: bus_i2c  # associate an ID
  # High frequency for better responsiveness
  frequency: 400kHz
  #frequency: 100kHz
  #frequency: 10kHz

# -------------------------------------------------------------------------
# MCP23017 EXPANDERS CONFIGURATION
# -------------------------------------------------------------------------
mcp23017:
  # --- FLOOR P0 (Ground Floor) ---
  # P0 Output Module (Relays) - Address 0x20
  - id: mcp_p0_out
    address: 0x20
  # P0 Input Module (Feedback/State) - Address 0x21
  - id: mcp_p0_in
    address: 0x21

  # --- FLOOR P1 (First Floor) ---

  # P1 Output Module (Relays) - Address 0x22
  - id: mcp_p1_out
    address: 0x22
  # P1 Input Module (Feedback/State) - Address 0x23
  - id: mcp_p1_in
    address: 0x23
    # Sharing the same interrupt pin as P0 (Wired-OR configuration)

# This script contains the C++ arrays and loops to read all sensors efficiently.
script:
  - id: read_all_inputs
    mode: queued
    then:
      - lambda: |-
          static const char *TAG = "sync";
          static uint32_t cycles = 0;

          // --- FLOOR P0 READ LOOP (12 Sensors) ---
          binary_sensor::BinarySensor *p0_sensors[] = {
            id(p0_state_01), id(p0_state_02), id(p0_state_03), id(p0_state_04),
            id(p0_state_05), id(p0_state_06), id(p0_state_07), id(p0_state_08),
            id(p0_state_09), id(p0_state_10), id(p0_state_11), id(p0_state_12)
          };
          light::LightState *p0_lights[] = {
            id(light_p0_01), id(light_p0_02), id(light_p0_03), id(light_p0_04),
            id(light_p0_05), id(light_p0_06), id(light_p0_07), id(light_p0_08),
            id(light_p0_09), id(light_p0_10), id(light_p0_11), id(light_p0_12)
          };

          for (int i = 0; i < 12; i++) {
            p0_sensors[i]->publish_state(id(mcp_p0_in).digital_read(i));
            const bool i2c_state = id(mcp_p0_in).digital_read(i);
            p0_sensors[i]->publish_state(i2c_state);

            // Force esphome light state to match real relay feedback even if there's no edge
            if (i2c_state) {
              if (!p0_lights[i]->current_values.is_on()) {
                ESP_LOGI(TAG, "[%s] i2c_state=1 -> esphome light ON (was OFF)", p0_lights[i]->get_name().c_str());
                auto call = p0_lights[i]->turn_on();
                call.perform();
              }
            } else {
              if (p0_lights[i]->current_values.is_on()) {
                ESP_LOGI(TAG, "[%s] i2c_state=1 -> esphome light OFF (was ON)", p0_lights[i]->get_name().c_str());
                auto call = p0_lights[i]->turn_off();
                call.perform();
              }
            }
          }

          // --- FLOOR P1 READ LOOP (15 Sensors) ---
          binary_sensor::BinarySensor *p1_sensors[] = {
            id(p1_state_01), id(p1_state_02), id(p1_state_03), id(p1_state_04),
            id(p1_state_05), id(p1_state_06), id(p1_state_07), id(p1_state_08),
            id(p1_state_09), id(p1_state_10), id(p1_state_11), id(p1_state_12),
            id(p1_state_13), id(p1_state_14), id(p1_state_15)
          };
          light::LightState *p1_lights[] = {
            id(light_p1_01), id(light_p1_02), id(light_p1_03), id(light_p1_04),
            id(light_p1_05), id(light_p1_06), id(light_p1_07), id(light_p1_08),
            id(light_p1_09), id(light_p1_10), id(light_p1_11), id(light_p1_12),
            id(light_p1_13), id(light_p1_14), id(light_p1_15)
          };
          for (int i = 0; i < 15; i++) {
            const bool i2c_state = id(mcp_p1_in).digital_read(i);
            p1_sensors[i]->publish_state(i2c_state);

            // Force HA light state to match real relay feedback even if there's no edge
            if (i2c_state) {
              if (!p1_lights[i]->current_values.is_on()) {
                ESP_LOGI(TAG, "[%s] i2c_state=1 -> esphome light ON (was OFF)", p1_lights[i]->get_name().c_str());
                auto call = p1_lights[i]->turn_on();
                call.perform();
              }
            } else {
              if (p1_lights[i]->current_values.is_on()) {
                ESP_LOGI(TAG, "[%s] i2c_state=1 -> esphome light OFF (was ON)", p1_lights[i]->get_name().c_str());
                auto call = p1_lights[i]->turn_off();
                call.perform();
              }
            }
          }

          // Periodic full dump: every 600 cycles (~60s @ 100ms)
          cycles++;
          if (cycles >= 600) {
            cycles = 0;
            ESP_LOGD(TAG, "---- FULL STATE DUMP ----");
            for (int i = 0; i < 12; i++) {
              const bool i2c_state = id(mcp_p0_in).digital_read(i);
              const bool esphome_light  = p0_lights[i]->current_values.is_on();
              ESP_LOGD(TAG, "P0[%02d] i2c_state=%d light=%d - [%s]", i+1, i2c_state ? 1 : 0, esphome_light ? 1 : 0, p0_lights[i]->get_name().c_str());
            }
            for (int i = 0; i < 15; i++) {
              const bool i2c_state = id(mcp_p1_in).digital_read(i);
              const bool esphome_light  = p1_lights[i]->current_values.is_on();
              ESP_LOGD(TAG, "P1[%02d] i2c_state=%d light=%d - [%s]", i+1, i2c_state ? 1 : 0, esphome_light ? 1 : 0, p1_lights[i]->get_name().c_str());
            }
            ESP_LOGD(TAG, "-------------------------");
          }

# --- MANUAL POLLING ENGINE (The Core) ---
# This component executes the lambda every 100ms.
# It manually reads the hardware pins and pushes the state to the sensors.
interval:
  - interval: 100ms
    then:
      - script.execute: read_all_inputs
# Secondo task: Debug I2C ogni 10s
  - interval: 20s
    then:
      - lambda: |-
          ESP_LOGD("debug_i2c", "--- Inizio Check I2C (0x20-0x23) ---");
          for (uint8_t address = 0x20; address <= 0x23; address++) {

            // CORREZIONE QUI: Usa .read(...) invece di .read_bytes(...)
            // Passiamo nullptr e 0 perché vogliamo solo vedere se risponde (ping)
            auto error = id(bus_i2c).read(address, nullptr, 0);

            if (error == i2c::ERROR_OK) {
              ESP_LOGD("debug_i2c", "Device 0x%02X: TROVATO", address);
            } else {
              ESP_LOGD("debug_i2c", "Device 0x%02X: -", address);
            }
          }
          ESP_LOGD("debug_i2c", "--- Fine Check ---");

# --- INTERRUPT WORKAROUND (The "Real-time" Trigger) ---
# Since MCP23017 doesn't support int_pin natively, we use a GPIO
# on the ESP32 to trigger a manual component update.
binary_sensor:
  - platform: gpio
    id: irq_handler
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
    internal: true
    # Scatta quando l'MCP porta il pin a massa (Active Low)
    filters:
      - invert:
      - delayed_off: 10ms # Minimum hardware debounce
    on_press:
      then:
        - script.execute: read_all_inputs

# -------------------------------------------------------------------------
# BINARY SENSORS (FEEDBACK) & SYNC LOGIC
# -------------------------------------------------------------------------
  # =======================================================================
  # FLOOR P0 - SENSORS
  # =======================================================================
  - platform: gpio
    id: p0_state_01
    pin: { mcp23xxx: mcp_p0_in, number: 0, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_01 }, then: [light.turn_on: light_p0_01], else: [light.turn_off: light_p0_01] } }] }

  - platform: gpio
    id: p0_state_02
    pin: { mcp23xxx: mcp_p0_in, number: 1, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_02 }, then: [light.turn_on: light_p0_02], else: [light.turn_off: light_p0_02] } }] }

  - platform: gpio
    id: p0_state_03
    pin: { mcp23xxx: mcp_p0_in, number: 2, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_03 }, then: [light.turn_on: light_p0_03], else: [light.turn_off: light_p0_03] } }] }

  - platform: gpio
    id: p0_state_04
    pin: { mcp23xxx: mcp_p0_in, number: 3, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_04 }, then: [light.turn_on: light_p0_04], else: [light.turn_off: light_p0_04] } }] }

  - platform: gpio
    id: p0_state_05
    pin: { mcp23xxx: mcp_p0_in, number: 4, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_05 }, then: [light.turn_on: light_p0_05], else: [light.turn_off: light_p0_05] } }] }

  - platform: gpio
    id: p0_state_06
    pin: { mcp23xxx: mcp_p0_in, number: 5, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_06 }, then: [light.turn_on: light_p0_06], else: [light.turn_off: light_p0_06] } }] }

  - platform: gpio
    id: p0_state_07
    pin: { mcp23xxx: mcp_p0_in, number: 6, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_07 }, then: [light.turn_on: light_p0_07], else: [light.turn_off: light_p0_07] } }] }

  - platform: gpio
    id: p0_state_08
    pin: { mcp23xxx: mcp_p0_in, number: 7, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_08 }, then: [light.turn_on: light_p0_08], else: [light.turn_off: light_p0_08] } }] }

  - platform: gpio
    id: p0_state_09
    pin: { mcp23xxx: mcp_p0_in, number: 8, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_09 }, then: [light.turn_on: light_p0_09], else: [light.turn_off: light_p0_09] } }] }

  - platform: gpio
    id: p0_state_10
    pin: { mcp23xxx: mcp_p0_in, number: 9, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_10 }, then: [light.turn_on: light_p0_10], else: [light.turn_off: light_p0_10] } }] }

  - platform: gpio
    id: p0_state_11
    pin: { mcp23xxx: mcp_p0_in, number: 10, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_11 }, then: [light.turn_on: light_p0_11], else: [light.turn_off: light_p0_11] } }] }

  - platform: gpio
    id: p0_state_12
    pin: { mcp23xxx: mcp_p0_in, number: 11, mode: INPUT }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p0_state_12 }, then: [light.turn_on: light_p0_12], else: [light.turn_off: light_p0_12] } }] }

  # =======================================================================
  # FLOOR P1 - SENSORS
  # =======================================================================
  - platform: gpio
    id: p1_state_01
    pin: { mcp23xxx: mcp_p1_in, number: 0, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_01 }, then: [light.turn_on: light_p1_01], else: [light.turn_off: light_p1_01] } }] }

  - platform: gpio
    id: p1_state_02
    pin: { mcp23xxx: mcp_p1_in, number: 1, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_02 }, then: [light.turn_on: light_p1_02], else: [light.turn_off: light_p1_02] } }] }

  - platform: gpio
    id: p1_state_03
    pin: { mcp23xxx: mcp_p1_in, number: 2, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_03 }, then: [light.turn_on: light_p1_03], else: [light.turn_off: light_p1_03] } }] }

  - platform: gpio
    id: p1_state_04
    pin: { mcp23xxx: mcp_p1_in, number: 3, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_04 }, then: [light.turn_on: light_p1_04], else: [light.turn_off: light_p1_04] } }] }

  - platform: gpio
    id: p1_state_05
    pin: { mcp23xxx: mcp_p1_in, number: 4, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_05 }, then: [light.turn_on: light_p1_05], else: [light.turn_off: light_p1_05] } }] }

  - platform: gpio
    id: p1_state_06
    pin: { mcp23xxx: mcp_p1_in, number: 5, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_06 }, then: [light.turn_on: light_p1_06], else: [light.turn_off: light_p1_06] } }] }

  - platform: gpio
    id: p1_state_07
    pin: { mcp23xxx: mcp_p1_in, number: 6, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_07 }, then: [light.turn_on: light_p1_07], else: [light.turn_off: light_p1_07] } }] }

  - platform: gpio
    id: p1_state_08
    pin: { mcp23xxx: mcp_p1_in, number: 7, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_08 }, then: [light.turn_on: light_p1_08], else: [light.turn_off: light_p1_08] } }] }

  - platform: gpio
    id: p1_state_09
    pin: { mcp23xxx: mcp_p1_in, number: 8, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_09 }, then: [light.turn_on: light_p1_09], else: [light.turn_off: light_p1_09] } }] }

  - platform: gpio
    id: p1_state_10
    pin: { mcp23xxx: mcp_p1_in, number: 9, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_10 }, then: [light.turn_on: light_p1_10], else: [light.turn_off: light_p1_10] } }] }

  - platform: gpio
    id: p1_state_11
    pin: { mcp23xxx: mcp_p1_in, number: 10, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_11 }, then: [light.turn_on: light_p1_11], else: [light.turn_off: light_p1_11] } }] }

  - platform: gpio
    id: p1_state_12
    pin: { mcp23xxx: mcp_p1_in, number: 11, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_12 }, then: [light.turn_on: light_p1_12], else: [light.turn_off: light_p1_12] } }] }

  - platform: gpio
    id: p1_state_13
    pin: { mcp23xxx: mcp_p1_in, number: 12, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_13 }, then: [light.turn_on: light_p1_13], else: [light.turn_off: light_p1_13] } }] }

  - platform: gpio
    id: p1_state_14
    pin: { mcp23xxx: mcp_p1_in, number: 13, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_14 }, then: [light.turn_on: light_p1_14], else: [light.turn_off: light_p1_14] } }] }

  - platform: gpio
    id: p1_state_15
    pin: { mcp23xxx: mcp_p1_in, number: 14, mode: INPUT_PULLUP }
    on_state: { then: [{ if: { condition: { binary_sensor.is_on: p1_state_15 }, then: [light.turn_on: light_p1_15], else: [light.turn_off: light_p1_15] } }] }

# -------------------------------------------------------------------------
# OUTPUTS DEFINITION
# -------------------------------------------------------------------------
output:
  # =======================================================================
  # FLOOR P0 - PHYSICAL RELAY PINS (Direct mapping to MCP pins)
  # =======================================================================
  - { platform: gpio, id: p0_relay_01, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 0 } }
  - { platform: gpio, id: p0_relay_02, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 1 } }
  - { platform: gpio, id: p0_relay_03, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 2 } }
  - { platform: gpio, id: p0_relay_04, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 3 } }
  - { platform: gpio, id: p0_relay_05, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 4 } }
  - { platform: gpio, id: p0_relay_06, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 5 } }
  - { platform: gpio, id: p0_relay_07, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 6 } }
  - { platform: gpio, id: p0_relay_08, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 7 } }
  - { platform: gpio, id: p0_relay_09, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 8 } }
  - { platform: gpio, id: p0_relay_10, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 9 } }
  - { platform: gpio, id: p0_relay_11, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 10 } }
  - { platform: gpio, id: p0_relay_12, inverted: true, pin: { mcp23xxx: mcp_p0_out, number: 11 } }

  # =======================================================================
  # FLOOR P1 - PHYSICAL RELAY PINS (Direct mapping to MCP pins)
  # =======================================================================
  - { platform: gpio, id: p1_relay_01, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 0 } }
  - { platform: gpio, id: p1_relay_02, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 1 } }
  - { platform: gpio, id: p1_relay_03, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 2 } }
  - { platform: gpio, id: p1_relay_04, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 3 } }
  - { platform: gpio, id: p1_relay_05, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 4 } }
  - { platform: gpio, id: p1_relay_06, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 5 } }
  - { platform: gpio, id: p1_relay_07, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 6 } }
  - { platform: gpio, id: p1_relay_08, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 7 } }
  - { platform: gpio, id: p1_relay_09, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 8 } }
  - { platform: gpio, id: p1_relay_10, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 9 } }
  - { platform: gpio, id: p1_relay_11, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 10 } }
  - { platform: gpio, id: p1_relay_12, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 11 } }
  - { platform: gpio, id: p1_relay_13, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 12 } }
  - { platform: gpio, id: p1_relay_14, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 13 } }
  - { platform: gpio, id: p1_relay_15, inverted: true, pin: { mcp23xxx: mcp_p1_out, number: 14 } }

  # =======================================================================
  # LOGIC TEMPLATES (PULSE GENERATORS)
  # These outputs handle the 0.5s pulse logic. They check the real state
  # before firing the relay to avoid sync issues.
  # =======================================================================

  # --- P0 Templates ---
  - platform: template
    id: p0_logic_01
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_01).state;' }, then: [output.turn_on: p0_relay_01, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_01] } }]
  - platform: template
    id: p0_logic_02
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_02).state;' }, then: [output.turn_on: p0_relay_02, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_02] } }]
  - platform: template
    id: p0_logic_03
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_03).state;' }, then: [output.turn_on: p0_relay_03, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_03] } }]
  - platform: template
    id: p0_logic_04
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_04).state;' }, then: [output.turn_on: p0_relay_04, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_04] } }]
  - platform: template
    id: p0_logic_05
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_05).state;' }, then: [output.turn_on: p0_relay_05, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_05] } }]
  - platform: template
    id: p0_logic_06
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_06).state;' }, then: [output.turn_on: p0_relay_06, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_06] } }]
  - platform: template
    id: p0_logic_07
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_07).state;' }, then: [output.turn_on: p0_relay_07, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_07] } }]
  - platform: template
    id: p0_logic_08
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_08).state;' }, then: [output.turn_on: p0_relay_08, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_08] } }]
  - platform: template
    id: p0_logic_09
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_09).state;' }, then: [output.turn_on: p0_relay_09, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_09] } }]
  - platform: template
    id: p0_logic_10
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_10).state;' }, then: [output.turn_on: p0_relay_10, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_10] } }]
  - platform: template
    id: p0_logic_11
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_11).state;' }, then: [output.turn_on: p0_relay_11, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_11] } }]
  - platform: template
    id: p0_logic_12
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p0_state_12).state;' }, then: [output.turn_on: p0_relay_12, delay: "${PULSE_DELAY}", output.turn_off: p0_relay_12] } }]

  # --- P1 Templates ---
  - platform: template
    id: p1_logic_01
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_01).state;' }, then: [output.turn_on: p1_relay_01, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_01] } }]
  - platform: template
    id: p1_logic_02
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_02).state;' }, then: [output.turn_on: p1_relay_02, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_02] } }]
  - platform: template
    id: p1_logic_03
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_03).state;' }, then: [output.turn_on: p1_relay_03, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_03] } }]
  - platform: template
    id: p1_logic_04
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_04).state;' }, then: [output.turn_on: p1_relay_04, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_04] } }]
  - platform: template
    id: p1_logic_05
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_05).state;' }, then: [output.turn_on: p1_relay_05, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_05] } }]
  - platform: template
    id: p1_logic_06
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_06).state;' }, then: [output.turn_on: p1_relay_06, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_06] } }]
  - platform: template
    id: p1_logic_07
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_07).state;' }, then: [output.turn_on: p1_relay_07, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_07] } }]
  - platform: template
    id: p1_logic_08
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_08).state;' }, then: [output.turn_on: p1_relay_08, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_08] } }]
  - platform: template
    id: p1_logic_09
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_09).state;' }, then: [output.turn_on: p1_relay_09, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_09] } }]
  - platform: template
    id: p1_logic_10
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_10).state;' }, then: [output.turn_on: p1_relay_10, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_10] } }]
  - platform: template
    id: p1_logic_11
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_11).state;' }, then: [output.turn_on: p1_relay_11, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_11] } }]
  - platform: template
    id: p1_logic_12
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_12).state;' }, then: [output.turn_on: p1_relay_12, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_12] } }]
  - platform: template
    id: p1_logic_13
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_13).state;' }, then: [output.turn_on: p1_relay_13, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_13] } }]
  - platform: template
    id: p1_logic_14
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_14).state;' }, then: [output.turn_on: p1_relay_14, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_14] } }]
  - platform: template
    id: p1_logic_15
    type: binary
    write_action: [{ if: { condition: { lambda: 'return (bool)state != id(p1_state_15).state;' }, then: [output.turn_on: p1_relay_15, delay: "${PULSE_DELAY}", output.turn_off: p1_relay_15] } }]

# -------------------------------------------------------------------------
# LIGHT ENTITIES (HOME ASSISTANT)
# -------------------------------------------------------------------------
light:
  # =======================================================================
  # FLOOR P0 LIGHTS (12 Items)
  # =======================================================================
  - { platform: binary, name: "Garage Plafoniera",       id: light_p0_01, output: p0_logic_01 }
  - { platform: binary, name: "Corridoio Scale P0",      id: light_p0_02, output: p0_logic_02 }
  - { platform: binary, name: "Bagno P0 Plafoniera",     id: light_p0_03, output: p0_logic_03 }
  - { platform: binary, name: "Sala Presa Comandata",    id: light_p0_04, output: p0_logic_04 }
  - { platform: binary, name: "Cucina Sottopensile",     id: light_p0_05, output: p0_logic_05 }
  - { platform: binary, name: "Cucina Plafoniera",       id: light_p0_06, output: p0_logic_06 }
  - { platform: binary, name: "Cucina Controsoffitto",   id: light_p0_07, output: p0_logic_07 }
  - { platform: binary, name: "Sala LED Finestre",       id: light_p0_08, output: p0_logic_08 }
  - { platform: binary, name: "Sala LED Centrali",       id: light_p0_09, output: p0_logic_09 }
  - { platform: binary, name: "Bagno P0 Specchio",       id: light_p0_10, output: p0_logic_10 }
  - { platform: binary, name: "Sottoscala",              id: light_p0_11, output: p0_logic_11 }
  - { platform: binary, name: "Garage Scaffali",         id: light_p0_12, output: p0_logic_12 }

  # =======================================================================
  # FLOOR P1 LIGHTS (15 Items)
  # =======================================================================
  - { platform: binary, name: "Ufficio Presa Comandata", id: light_p1_01, output: p1_logic_01 }
  - { platform: binary, name: "Ufficio Plafoniera",      id: light_p1_02, output: p1_logic_02 }
  - { platform: binary, name: "Bagno P1 Plafoniera",     id: light_p1_03, output: p1_logic_03 }
  - { platform: binary, name: "Matrimoniale Plafoniera", id: light_p1_04, output: p1_logic_04 }
  - { platform: binary, name: "Matrimoniale Presa",      id: light_p1_05, output: p1_logic_05 }
  - { platform: binary, name: "Bimbi Plafoniera",        id: light_p1_06, output: p1_logic_06 }
  - { platform: binary, name: "Bimbi Presa Comandata",   id: light_p1_07, output: p1_logic_07 }
  - { platform: binary, name: "Scale P1",                id: light_p1_08, output: p1_logic_08 }
  - { platform: binary, name: "Corridoio P1",            id: light_p1_09, output: p1_logic_09 }
  - { platform: binary, name: "Bagno P1 Specchio",       id: light_p1_10, output: p1_logic_10 }
  - { platform: binary, name: "Ufficio Notturna",        id: light_p1_11, output: p1_logic_11 }
  - { platform: binary, name: "Armadi",                  id: light_p1_12, output: p1_logic_12 }
  - { platform: binary, name: "Stireria Plafoniere",     id: light_p1_13, output: p1_logic_13 }
  - { platform: binary, name: "Stireria LED",            id: light_p1_14, output: p1_logic_14 }
  - { platform: binary, name: "Sottotetto Sala Server",  id: light_p1_15, output: p1_logic_15 }
